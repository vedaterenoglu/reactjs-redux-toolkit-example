
--COMMENTS

TASK: Update File Header Comments
SCOPE: All source files EXCEPT test files and configuration files
OBJECTIVE: Add meaningful, accurate header documentation that reflects actual file contents and architectural decisions.
ANALYSIS REQUIREMENTS:

READ and understand each file's actual implementation
IDENTIFY file's primary responsibility and role
DETECT genuine design patterns if present
RECOGNIZE SOLID principles where actually applied
AVOID forced or generic documentation

HEADER FORMAT (Adaptive based on file type):
For Classes/Services (Complex Logic)
typescript/**
 * [Primary Responsibility] - [Brief description of what this does]
 * 
 * Responsibilities:
 * - [Specific responsibility 1]
 * - [Specific responsibility 2]
 * 
 * Architecture:
 * - SOLID Principles: [Only list principles actually demonstrated]
 * - Patterns: [Only list patterns actually implemented]
 * 
 * Dependencies: [Key dependencies if relevant]
 */
For Utilities/Helpers (Simple Functions)
typescript/**
 * [Brief description of utility purpose]
 * 
 * Provides: [What functionality this offers]
 * Used by: [Where this is typically used]
 */
For Types/Interfaces (Type Definitions)
typescript/**
 * Type definitions for [Domain/Feature area]
 * 
 * Defines: [What these types represent]
 * Used in: [Where these types are consumed]
 */
For Components (React/UI)
typescript/**
 * [Component name] - [UI purpose and behavior]
 * 
 * Features:
 * - [Key feature 1]
 * - [Key feature 2]
 * 
 * Props: [Brief description of key props]
 * State: [State management approach if complex]
 */
PATTERN IDENTIFICATION GUIDE:
Common Design Patterns to Look For:

Singleton: Single instance classes
Factory: Object creation logic
Observer: Event/state subscription
Strategy: Interchangeable algorithms
Decorator: Behavior enhancement
Repository: Data access abstraction
Command: Action encapsulation
Builder: Complex object construction

SOLID Principles Detection:

S (SRP): File has single, clear responsibility
O (OCP): Extensible without modification
L (LSP): Substitution compatibility (inheritance)
I (ISP): Interface segregation (multiple small interfaces)
D (DIP): Depends on abstractions, not concretions

IMPLEMENTATION RULES:

BE HONEST: Only document what's actually present
BE SPECIFIC: Describe actual functionality, not aspirational goals
BE CONCISE: Headers should be scannable, not essays
BE ACCURATE: Ensure documentation matches implementation

EXAMPLES:
Good Example (Service Class):
typescript/**
 * User authentication service with JWT token management
 * 
 * Responsibilities:
 * - Validates user credentials
 * - Generates and verifies JWT tokens
 * - Manages user session state
 * 
 * Architecture:
 * - SOLID Principles: SRP (single auth responsibility), DIP (depends on interfaces)
 * - Patterns: Strategy (multiple auth providers), Singleton (single auth instance)
 * 
 * Dependencies: JWT library, user repository interface
 */
Good Example (Utility):
typescript/**
 * Date formatting utilities for consistent display across application
 * 
 * Provides: Standardized date/time formatting functions
 * Used by: UI components, reports, data exports
 */
Bad Example (Forced):
typescript/**
 * Simple constants file
 * 
 * SOLID Principles: SRP, OCP, LSP, ISP, DIP  // ❌ Generic/forced
 * Design Patterns: Factory, Observer, Strategy  // ❌ Not actually present
 */
CONDITIONAL DOCUMENTATION:
Skip Pattern/Principle Documentation If:

File contains only constants or simple types
File has single utility function
File is simple data structure or configuration
No meaningful patterns or principles apply

Required for All Files:

Primary purpose/responsibility
Brief description of contents
Usage context where helpful

VALIDATION CRITERIA:

Header accurately reflects file contents
No generic or copy-pasted comments
Patterns/principles mentioned are actually implemented
Documentation adds value for developers
Headers are maintainable and won't quickly become outdated

IMPLEMENTATION WORKFLOW:

ANALYZE file structure and purpose
IDENTIFY genuine patterns and principles
WRITE appropriate header based on file complexity
VERIFY accuracy against actual implementation
ENSURE header adds value for future developers

MAINTENANCE STRATEGY:

Update headers when major refactoring occurs
Remove outdated pattern/principle references
Keep documentation aligned with code changes
Regular review during code reviews

COMPLETION CRITERIA:

All source files have appropriate headers
Headers accurately reflect file contents
No forced or generic documentation
Documentation provides genuine value for code understanding


--------------------------------------------------------------------------------
--PROJECT--MD

TASK: Create Comprehensive AI Agent Development Reference or update the document

TARGET: src/documents/ignore/PROJECT.md

OBJECTIVE: Generate a complete, AI-consumable documentation that enables autonomous development decisions and accurate code generation.
PRE-DOCUMENTATION ANALYSIS:

SCAN entire project structure and catalog all files
ANALYZE package.json for dependencies and scripts
EXAMINE configuration files (tsconfig, eslint, prettier, etc.)
REVIEW existing code patterns and architectural decisions
IDENTIFY API routes, components, and data models
DOCUMENT current testing setup and coverage
ANALYZE git history for recent development patterns

AI AGENT OPTIMIZATION REQUIREMENTS:

STRUCTURED DATA: Use consistent headings, lists, and code blocks
EXPLICIT CONTEXT: State assumptions, constraints, and conventions clearly
ACTIONABLE EXAMPLES: Include code samples for common patterns
DECISION TREES: Provide guidance for when to use different approaches
VALIDATION RULES: Include testing and quality requirements
ERROR PATTERNS: Document common issues and their solutions

DOCUMENTATION STRUCTURE:
1. PROJECT OVERVIEW
markdown### Project Type
[Next.js/React/Node.js/etc. - specific version]

### Core Purpose
[Brief description of what the application does]

### Key Stakeholders
[Who uses this - internal tools, customer-facing, etc.]
2. ARCHITECTURE BLUEPRINT
markdown### File Structure
src/
├── components/     # [Purpose and patterns]
├── pages/         # [Routing strategy]
├── api/           # [API organization]
├── lib/           # [Utilities and helpers]
├── types/         # [Type definitions]
├── hooks/         # [Custom React hooks]
└── styles/        # [Styling approach]

### Technology Stack
- **Framework**: [Version and key features used]
- **Database**: [Type, ORM, connection patterns]
- **Authentication**: [Strategy and implementation]
- **State Management**: [Redux/Context/etc.]
- **Styling**: [CSS-in-JS/Tailwind/etc.]
- **Testing**: [Jest/Cypress/etc.]
- **Deployment**: [Platform and CI/CD]
3. DEVELOPMENT PATTERNS
markdown### SOLID Principles Implementation
- **Single Responsibility**: [How it's applied, examples]
- **Open/Closed**: [Extension patterns used]
- **Liskov Substitution**: [Interface contracts]
- **Interface Segregation**: [API design approach]
- **Dependency Inversion**: [Injection patterns]

### Design Patterns in Use
- **Pattern Name**: [Where used, implementation example]
- **Another Pattern**: [Context and code sample]

### Code Organization Rules
- File naming conventions: [kebab-case/PascalCase/etc.]
- Import order: [External, internal, relative]
- Component structure: [Props, state, effects, render]
- Function organization: [Pure functions first, etc.]
4. COMPONENT SYSTEM
markdown### Component Hierarchy
App
├── Layout
│   ├── Header
│   ├── Navigation
│   └── Footer
├── Pages
│   ├── Home
│   ├── Dashboard
│   └── Settings
└── Shared
├── UI Components
├── Forms
└── Modals

### Component Patterns
- **Props Interface**: [How to define component props]
- **State Management**: [Local vs global state decisions]
- **Event Handling**: [Standard patterns used]
- **Error Boundaries**: [How errors are handled]

### Reusable Component Standards
[Examples of well-implemented components to copy]
5. API ARCHITECTURE
markdown### Endpoint Patterns
- **REST Conventions**: [How routes are structured]
- **Error Handling**: [Standard error response format]
- **Authentication**: [How to protect routes]
- **Validation**: [Request/response validation approach]

### Data Flow
[Request → Validation → Business Logic → Database → Response]

### API Examples
```typescript
// Standard API route pattern
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // [Standard implementation pattern]
}

## 6. DATABASE & DATA MODELS
```markdown
### Schema Organization
- **User Model**: [Fields, relationships, constraints]
- **Business Entities**: [Core data structures]
- **Relationships**: [How entities connect]

### Query Patterns
- **CRUD Operations**: [Standard patterns]
- **Complex Queries**: [Joins, aggregations]
- **Performance**: [Indexing strategy]

### Migration Strategy
[How database changes are handled]
7. TESTING STRATEGY
markdown### Test Organization
src/
├── tests/           # Unit tests
├── components/tests/ # Component tests
└── api/tests/       # API integration tests

### Testing Patterns
- **Unit Tests**: [What and how to test]
- **Integration Tests**: [API and database testing]
- **Component Tests**: [React component testing]
- **E2E Tests**: [Critical user flows]

### Test Standards
- **Coverage Requirements**: [Minimum thresholds]
- **Mock Strategy**: [What to mock vs test]
- **Test Data**: [How to handle test data]
8. CODE QUALITY STANDARDS
markdown### TypeScript Configuration
- **Strict Mode**: [Rules enforced]
- **Type Definitions**: [How to define types]
- **Interface Design**: [Naming and structure]

### ESLint Rules
- **Enforced Rules**: [Key rules and reasons]
- **Custom Rules**: [Project-specific rules]
- **Error vs Warning**: [Severity levels]

### Prettier Configuration
[Formatting standards and automation]

### Quality Gates
- **Pre-commit**: [Hooks and checks]
- **CI/CD**: [Automated quality checks]
- **Code Review**: [Review checklist]
9. DEVELOPMENT WORKFLOW
markdown### Branch Strategy
[Git workflow and naming conventions]

### Commit Standards
[Conventional commits format and requirements]

### Development Process
1. [Step-by-step development workflow]
2. [Testing requirements]
3. [Review process]
4. [Deployment steps]

### Common Commands
```bash
npm run dev          # [What this does]
npm run test         # [Testing command]
npm run build        # [Build process]
npm run lint         # [Linting check]

## 10. AI AGENT DECISION FRAMEWORK
```markdown
### When to Create New Components
- [Criteria for component creation]
- [Reusability thresholds]
- [Component size guidelines]

### API Route Decision Tree
- [When to create new endpoints]
- [RESTful design principles]
- [Error handling requirements]

### Testing Requirements
- [What requires unit tests]
- [Integration test criteria]
- [Component test standards]

### Code Quality Checklist
- [ ] TypeScript types defined
- [ ] ESLint errors resolved
- [ ] Tests written and passing
- [ ] Documentation updated
- [ ] Performance considered
11. CONSTRAINTS AND LIMITATIONS
markdown### Technical Constraints
- [Database limitations]
- [Performance requirements]
- [Security requirements]
- [Browser support]

### Development Constraints
- [No 'any' types allowed]
- [No eslint-disable statements]
- [Required test coverage]
- [Code review requirements]

### Business Constraints
- [User experience requirements]
- [Accessibility standards]
- [Compliance requirements]
ACCURACY VALIDATION:

ALL information reflects current codebase state
NO outdated dependency versions
NO planned features documented as current
ALL code examples compile and work
ALL file paths exist and are accurate

AI AGENT CONSUMPTION FEATURES:

Consistent markdown formatting for parsing
Code blocks with language specification
Clear decision criteria and thresholds
Explicit examples for common patterns
Searchable section headers
Action-oriented language

COMPLETION CRITERIA:

Document covers all major architectural decisions
Examples are copy-pasteable and functional
AI agents can make autonomous development decisions
Information is current and verified accurate
Structure supports quick reference and deep dives

STATUS: WAIT for completion verification and AI agent compatibility testing

--------------------------------------------------------------------------------
--README-MD

TASK: Create Comprehensive README Documentation Architecture
OBJECTIVE: Build a scalable, user-friendly documentation system that serves different visitor types and information needs.
PRE-DOCUMENTATION ANALYSIS:

IDENTIFY project type and primary use cases
CATALOG all major features and components
ANALYZE target audiences (contributors, users, maintainers)
REVIEW existing documentation gaps and pain points
DETERMINE information hierarchy and relationships

AUDIENCE-DRIVEN STRUCTURE:
Primary Audiences:

New Contributors: Need setup, contribution guidelines, architecture overview
End Users: Need installation, usage examples, troubleshooting
Maintainers: Need deployment, configuration, advanced features
Evaluators: Need quick understanding of capabilities and tech stack

SUB-DOCUMENT STRATEGY:
Core Sub-Documents (Required):
src/documents/readme-sub-documents/
├── SETUP.md              # Installation and environment setup
├── USAGE.md              # Basic usage examples and common tasks
├── ARCHITECTURE.md       # System design and component overview
├── CONTRIBUTING.md       # Development workflow and guidelines
├── API.md                # API documentation (if applicable)
├── DEPLOYMENT.md         # Production deployment guide
├── TROUBLESHOOTING.md    # Common issues and solutions
└── CHANGELOG.md          # Version history and updates
Feature-Specific Sub-Documents (Conditional):
├── AUTHENTICATION.md     # Auth system documentation
├── DATABASE.md           # Database schema and migrations
├── TESTING.md           # Testing strategy and examples
├── CONFIGURATION.md      # Environment and config options
├── INTEGRATIONS.md       # Third-party service integrations
├── PERFORMANCE.md        # Optimization and monitoring
└── SECURITY.md          # Security considerations and best practices
MAIN README.md STRUCTURE:
Optimized README Template:
markdown# Project Name
Brief, compelling description (1-2 sentences)

[![Build Status](badge-url)](link) [![Coverage](badge-url)](link)

## ✨ Key Features
- Feature 1 (brief description)
- Feature 2 (brief description)
- Feature 3 (brief description)

## 🚀 Quick Start
```bash
# Essential commands only
npm install
npm run dev
📚 Documentation
For Users

📖 Usage Guide - Examples and common tasks
🔧 Setup Instructions - Detailed installation
🆘 Troubleshooting - Common issues

For Developers

🏗️ Architecture Overview - System design
🤝 Contributing Guide - Development workflow
🧪 Testing Guide - Test strategy

For DevOps

🚀 Deployment Guide - Production setup
⚙️ Configuration - Environment setup

🛠️ Tech Stack

Framework: [Name and version]
Database: [Type and version]
Key Libraries: [List major dependencies]

📄 License
[License type]

SUB-DOCUMENT CONTENT STANDARDS:

### SETUP.md Template:
```markdown
# Setup Guide

## Prerequisites
- System requirements
- Required software versions

## Installation Steps
1. Detailed step-by-step instructions
2. Environment configuration
3. Database setup (if needed)
4. Verification steps

## Development Environment
- IDE recommendations
- Extensions and tools
- Local development workflow

## Troubleshooting Setup
- Common installation issues
- Platform-specific notes
ARCHITECTURE.md Template:
markdown# Architecture Overview

## System Design
- High-level architecture diagram
- Component relationships
- Data flow overview

## Directory Structure
- Folder organization
- File naming conventions
- Module responsibilities

## Key Design Decisions
- Architectural patterns used
- Technology choices rationale
- Trade-offs and constraints

## Integration Points
- External services
- Database connections
- API endpoints
CONTRIBUTING.md Template:
markdown# Contributing Guide

## Development Workflow
- Git branching strategy
- Commit message format
- Pull request process

## Code Standards
- Style guide
- Linting rules
- Testing requirements

## Getting Started
- First contribution steps
- Local development setup
- Testing your changes

## Review Process
- What reviewers look for
- Common feedback themes
- Approval criteria
CONTENT REQUIREMENTS:
Main README Constraints:

Length: 100-200 lines maximum
Scan Time: 30 seconds to understand project
Action Items: Clear next steps for each audience
Visual: Use emojis, badges, and formatting for scannability

Sub-Document Requirements:

Depth: Comprehensive technical details
Examples: Code samples and use cases
Maintenance: Easy to update and version
Cross-Links: Reference related documents

CROSS-REFERENCE MAPPING:
Navigation Strategy:
Main README Section → Sub-Document(s)
├── Quick Start → SETUP.md, USAGE.md
├── Features → Feature-specific docs
├── Development → CONTRIBUTING.md, ARCHITECTURE.md
├── Deployment → DEPLOYMENT.md, CONFIGURATION.md
└── Troubleshooting → TROUBLESHOOTING.md, FAQ.md
Link Organization:

Group links by audience type
Use descriptive link text
Include brief description for each link
Maintain consistent formatting

VALIDATION CRITERIA:
Main README Success Metrics:

 Project purpose clear in 10 seconds
 Installation possible in 5 minutes
 Key features immediately obvious
 Next steps clear for each audience type
 No critical information missing from overview

Sub-Document Quality Checks:

 Each document serves specific audience need
 Technical details sufficient for implementation
 Examples are copy-pasteable and functional
 Cross-references are accurate and helpful
 Information is current and tested

MAINTENANCE STRATEGY:
Update Triggers:

New feature additions
Architecture changes
Dependency updates
User feedback
Onboarding difficulties

Review Schedule:

Monthly accuracy check
Quarterly structure review
Release-based content updates
User feedback integration

IMPLEMENTATION WORKFLOW:

ANALYZE current project structure and identify gaps
PLAN sub-document structure based on project needs
CREATE sub-documents with comprehensive content
UPDATE main README with streamlined overview
LINK all documents with clear navigation
TEST documentation with new contributor workflow
ITERATE based on feedback and usage patterns

DELIVERABLES:

Sub-Document List: Recommended files with purpose descriptions
README Structure: Optimized main README outline
Cross-Reference Map: Navigation between documents
Content Templates: Standardized formats for each document type
Maintenance Plan: Strategy for keeping documentation current

SUCCESS DEFINITION:

New contributors can start developing within 15 minutes
Users can install and run project within 5 minutes
Evaluators can understand project value within 2 minutes
Maintainers have clear deployment and configuration guidance

------------------------------------------------------------------------------
--SEARCH

DIRECTIVE: Intelligent Research and Problem-Solving Protocol

MISSION: Provide accurate, current, and comprehensive solutions by leveraging all available research resources when knowledge gaps are identified.
RESEARCH TRIGGERS:
Immediate Research Required:

Technology/framework versions newer than knowledge cutoff
Current best practices that may have evolved
Specific implementation details not in base knowledge
Error messages or issues not previously encountered
Integration patterns with unfamiliar tools/services
Security considerations for recent vulnerabilities
Performance optimization techniques for specific scenarios

Research Assessment Criteria:
IF (question involves post-cutoff information OR
    specific implementation details OR
    current best practices OR
    unfamiliar tools/errors)
THEN research_required = TRUE
RESOURCE PRIORITIZATION HIERARCHY:
Tier 1: Authoritative Sources (Use First)

Official Documentation

Framework docs (React, Next.js, etc.)
API documentation
Library/package official docs
Platform documentation (Vercel, AWS, etc.)


Web Search for Current Info

Recent blog posts from reputable sources
Stack Overflow solutions with recent activity
GitHub issues and discussions
Community-maintained resources



Tier 2: Specialized Resources (Use When Needed)

MCP Servers & APIs

Specialized functionality access
Real-time data requirements
Service-specific integrations


Community Resources

Reddit discussions
Discord/Slack communities
YouTube tutorials (recent)
Developer blogs and newsletters



RESEARCH METHODOLOGY:
Step 1: Define Research Scope

What specifically needs to be researched?
What level of detail is required?
Are there time-sensitive factors?
What are the success criteria?

Step 2: Source Selection Strategy
FOR official_docs IN [framework, library, platform]:
    IF available AND current:
        prioritize(official_docs)

FOR community_sources IN [stackoverflow, github, blogs]:
    IF recent AND well_reviewed:
        include(community_sources)

FOR experimental_sources IN [alpha_docs, discussions]:
    IF no_stable_solution_found:
        investigate(experimental_sources)
Step 3: Information Validation

Cross-reference multiple sources
Check publication/update dates
Verify compatibility with current project stack
Test solutions in safe environment when possible
Document source reliability for future reference

RESEARCH EXECUTION WORKFLOW:
Phase 1: Quick Assessment (30 seconds)

Identify specific knowledge gap
Determine if information might be time-sensitive
Assess confidence level in existing knowledge
Decide research scope and priority

Phase 2: Targeted Research (2-5 minutes)

Search official documentation first
Query web search for current best practices
Review recent community discussions
Validate findings across multiple sources

Phase 3: Solution Integration (1-2 minutes)

Synthesize research findings
Adapt solutions to specific context
Include source attribution
Note any assumptions or limitations

QUALITY ASSURANCE:
Source Reliability Indicators:

✅ Official documentation
✅ Recent posts (< 6 months for fast-moving tech)
✅ High community engagement/upvotes
✅ Multiple corroborating sources
✅ Code examples that compile/work
⚠️ Single source without verification
❌ Outdated information (> 2 years for frameworks)
❌ Deprecated or experimental features
❌ Unverified community posts

Validation Checklist:

 Information is current and accurate
 Solution is compatible with project requirements
 Code examples are tested and functional
 Security implications considered
 Performance impact assessed
 Alternative approaches evaluated

COMMUNICATION STANDARDS:
When Presenting Research-Based Solutions:
markdownBased on current documentation/community best practices:

[Solution with clear implementation]

Sources consulted:
- [Primary source with link]
- [Secondary source with link]

Last verified: [Date]
Compatibility: [Version/framework info]
Research Transparency:

Always cite sources when research was conducted
Mention recency of information when relevant
Note confidence level in solution
Suggest verification for critical implementations
Provide fallback options when available

RESEARCH SCOPE GUIDELINES:
Research Depth by Context:

Critical Production Issues: Deep research with multiple sources
Feature Development: Balanced research with practical focus
Learning/Exploration: Comprehensive research with educational value
Quick Questions: Targeted research with fast turnaround

Time Management:

Maximum 5 minutes for most research tasks
Escalate to comprehensive research only for critical/complex issues
Document findings for future reference
Build knowledge base of reliable sources

SPECIALIZED RESEARCH SCENARIOS:
For New Technologies:

Check official getting-started guides
Review GitHub repositories and examples
Search for adoption experiences and gotchas
Verify compatibility with existing stack

For Error Resolution:

Search exact error message
Check issue trackers (GitHub, etc.)
Review Stack Overflow solutions
Verify solutions are current and tested

For Best Practices:

Consult official style guides
Review recent conference talks/articles
Check community consensus on forums
Validate with multiple expert sources

CONTINUOUS IMPROVEMENT:
Knowledge Base Building:

Maintain list of reliable sources by technology
Track which research approaches work best
Update source reliability based on experience
Share valuable findings for team benefit

Research Skill Development:

Improve search query effectiveness
Develop faster source evaluation skills
Build network of trusted information sources
Stay current with technology evolution

SUCCESS METRICS:

Solutions based on current, accurate information
Reduced time-to-solution through effective research
Higher confidence in recommendations
Better outcomes from researched solutions
Improved knowledge base over time


------------------------------------------------------------------------------
--READ

TASK: Read and Process CLAUDE.md File

ACTION: Access and analyze CLAUDE.md content
- Parse all instructions and directives
- Note project-specific requirements
- Apply guidelines to current context

EXECUTE: Immediate file read operation required

-------------------------------------------------------------------------------
--SYSTEMATIC

DIRECTIVE: Systematic Engineering Excellence

PRINCIPLE: Apply rigorous engineering methodology with appropriate iteration for optimal outcomes.
CORE PHILOSOPHY: Maximum preparation, minimum waste, deliberate iteration when needed.
PROBLEM CLASSIFICATION FRAMEWORK:
Type A: Well-Defined Problems (Single-Pass Approach)

Characteristics: Clear requirements, known patterns, established solutions
Examples: CRUD operations, standard integrations, documented APIs
Approach: Deep analysis → Complete implementation → Validation

Type B: Complex Problems (Structured Iteration)

Characteristics: Multiple unknowns, integration complexity, performance constraints
Examples: System architecture, optimization, multi-service integration
Approach: Analysis → Prototype → Validate → Refine → Complete

Type C: Exploratory Problems (Research-First Approach)

Characteristics: New technologies, unclear requirements, proof-of-concept
Examples: New framework adoption, algorithm development, experimental features
Approach: Research → Spike → Learn → Design → Implement

SYSTEMATIC ANALYSIS FRAMEWORK:

Phase 1: Problem Definition

WHAT: What exactly needs to be solved?
WHY: What business/technical problem does this address?
WHO: Who are the stakeholders and users?
WHEN: What are the time constraints and dependencies?
WHERE: What system/component boundaries are involved?
HOW: What are the technical constraints and requirements?

Phase 2: Solution Architecture

INPUTS: What data/parameters are required?
OUTPUTS: What results/side effects are expected?
DEPENDENCIES: What external systems/services are involved?
CONSTRAINTS: What limitations (performance, security, etc.) apply?
PATTERNS: What established patterns or solutions exist?
RISKS: What could go wrong and how to mitigate?

Phase 3: Implementation Strategy

APPROACH: Which problem type (A, B, or C) is this?
SEQUENCE: What order should components be built?
VALIDATION: How will success be measured?
ROLLBACK: What's the plan if issues arise?

EXECUTION METHODOLOGIES:
For Type A (Well-Defined) Problems:
1. ANALYZE requirements and constraints thoroughly
2. DESIGN complete solution with clear interfaces
3. IMPLEMENT with established patterns and practices
4. VALIDATE against requirements
5. DELIVER complete solution
Expected Outcome: Single implementation cycle

For Type B (Complex) Problems:
1. ANALYZE problem and identify key unknowns
2. DESIGN overall architecture with clear phases
3. IMPLEMENT core functionality first
4. VALIDATE approach with stakeholders/tests
5. REFINE based on learnings
6. COMPLETE remaining components
7. DELIVER integrated solution

Expected Outcome: 2-3 structured iterations
For Type C (Exploratory) Problems:
1. RESEARCH existing solutions and approaches
2. SPIKE minimal viable implementation
3. LEARN from initial results and constraints
4. DESIGN production-ready solution
5. IMPLEMENT with full engineering rigor
6. DELIVER complete solution with documentation

Expected Outcome: Research + 1-2 implementation cycles
ENGINEERING STANDARDS:
Analysis Quality Gates:

 Problem clearly defined and bounded
 Success criteria explicitly stated
 Technical constraints identified
 Dependencies mapped and understood
 Risk assessment completed
 Implementation approach selected

Implementation Standards:

Code Quality: TypeScript, linting, testing standards maintained
Architecture: SOLID principles and design patterns applied
Documentation: Clear comments and technical documentation
Testing: Appropriate test coverage for problem complexity
Performance: Scalability and efficiency considered

Validation Requirements:

Functional: Does it solve the stated problem?
Technical: Does it meet quality and performance standards?
Integration: Does it work within the broader system?
Maintainable: Can it be understood and modified by others?

DECISION FRAMEWORK:
When to Use Single-Pass Approach:

✅ Problem has been solved before in similar contexts
✅ Requirements are clear and stable
✅ Technical approach is well-established
✅ Risk of failure is low
✅ Time pressure is high

When Structured Iteration is Appropriate:

✅ Problem involves multiple complex systems
✅ Performance requirements are critical
✅ Integration points are numerous or untested
✅ Solution affects multiple stakeholders
✅ Feedback loops are essential for success

When Research-First is Necessary:

✅ Technology stack is new or unfamiliar
✅ Requirements are emerging or unclear
✅ Multiple solution approaches exist
✅ Innovation or optimization is primary goal
✅ Learning is as important as delivery

QUALITY ASSURANCE:
Predictive Accuracy Metrics:

Estimation Accuracy: How close are time estimates to actual?
Requirement Stability: How often do requirements change?
Defect Rate: How many issues emerge post-delivery?
Rework Percentage: How much code needs significant changes?

Continuous Improvement:

Retrospective Analysis: What led to unexpected iterations?
Pattern Recognition: What problem types are being misclassified?
Skill Development: What analysis skills need improvement?
Tool Enhancement: What tools could improve prediction accuracy?

COMMUNICATION STANDARDS:
Before Implementation:
markdown## Problem Analysis
- **Type**: [A/B/C] - [Justification]
- **Approach**: [Single-pass/Structured/Research-first]
- **Expected Iterations**: [1/2-3/Research + 1-2]
- **Key Risks**: [Risk 1, Risk 2, Risk 3]
- **Success Criteria**: [Measurable outcomes]
During Implementation:

Progress Updates: Clear milestone communication
Issue Escalation: Early warning when assumptions prove incorrect
Scope Changes: Transparent communication about requirement shifts

After Delivery:

Retrospective: Analysis of prediction accuracy
Lessons Learned: Insights for future similar problems
Knowledge Sharing: Patterns and solutions for team benefit

ANTI-PATTERNS TO AVOID:
Analysis Paralysis:

Spending more time analyzing than implementing simple problems
Over-engineering solutions for straightforward requirements
Perfectionism preventing progress on working solutions

Premature Optimization:

Optimizing before understanding actual constraints
Solving problems that don't exist yet
Complex solutions for simple requirements

Iteration Addiction:

Defaulting to "figure it out as we go" approach
Not investing in upfront analysis for well-understood problems
Treating all problems as if they require exploration

SUCCESS DEFINITION:

Right amount of analysis for problem complexity
Predictable delivery with minimal waste
High-quality solutions that meet requirements
Continuous improvement in prediction accuracy
Team confidence in engineering approach

EXECUTION MANDATE:
Apply systematic rigor appropriate to problem complexity, with deliberate iteration only when uncertainty genuinely requires it.


--------------------------------------------------------------------------------
--Consistency

Regarding the Claude.md file and it's subdocuments and the Project.md file perform a comprehensive inspection of the entire project to identify violations and inconsistencies across multiple dimensions:

Inspect:

  1. Project Structure Consistency

  - File naming conventions (kebab-case vs camelCase vs PascalCase)
  - Directory organization patterns (atoms/molecules/organisms vs other structures)
  - Module organization (where services, utils, types are placed)
  - Test file placement and naming (.test.ts vs tests folders)

  2. Implementation Consistency

  - Component patterns (Client vs Server Components usage)
  - State management patterns (Zustand vs React Context vs props)
  - Data fetching patterns (Server Components vs Apollo Client vs Server Actions)
  - Error handling approaches
  - Form handling patterns (React Hook Form usage)
  - Authentication/authorization patterns

  3. UI/UX Consistency

  - Component library usage (shadcn/ui vs custom components)
  - Styling approaches (Tailwind classes vs CSS modules vs inline styles)
  - Responsive design patterns
  - Icon usage patterns
  - Loading states and skeletons
  - Error state presentations
  - Toast/notification patterns

  4. Code Quality Consistency

  - TypeScript usage (any types, proper interfaces)
  - File header comments (SOLID principles documentation)
  - Import organization
  - ESLint rule compliance
  - Component decomposition adherence

  5. Testing Consistency

  - Test coverage requirements
  - Mock data usage patterns
  - Test file organization
  - Testing patterns and approaches

  6. i18n Consistency

  - Translation key naming patterns
  - Missing translations across languages
  - Translation file structure

  7. Configuration Consistency

  - Environment variable usage
  - Configuration file patterns
  - Build/deployment configurations

Scan the entire codebase systematically to identify violations in each of these areas and create a comprehensive list of inconsistencies that need to be addressed.

Give the report and wait!!!!!!!!!!!!!!!!!!!!!


--------------------------------------------------------------------------------
# Production Environment Configuration

VITE_CLERK_PUBLISHABLE_KEY=pk_test_c2V0dGxlZC10b3J0b2lzZS00OS5jbGVyay5hY2NvdW50cy5kZXYk
VITE_STRIPE_PUBLISHABLE_KEY=pk_test_51RZ75PGd6V04F1vrVuM04sGqwxO3Nx6EFLQ0m61pmbtcgcSPU2CGNHgZsYygBrw2mq8KM1Yna8IVxhLVK4uKa59300KUXVKqtL
VITE_API_BASE_URL=https://portfolio-events-rest-api-i6z5q.ondigitalocean.app
VITE_APP_NAME=Online Ticket
VITE_APP_URL=https://reactjs-redux-thunk-example.demo.vedaterenoglu.com


⏺ ✅ THE SOLUTION WITHOUT VERCEL.JSON

  After deep research, here's how millions of SPAs handle Stripe without routing
  issues:

  SOLUTION: Redirect to ROOT URL with Query Parameters

  Instead of:
  const successUrl = getAppUrl(`/events/${slug}/payment-success`)

  Use:
  const successUrl = getAppUrl(`/?payment=success&event=${slug}`)

  WHY THIS WORKS:

  1. Root URL always exists - Vercel will ALWAYS serve / (your index.html)
  2. No 404 possible - Root URL is guaranteed to work
  3. React takes over - Once React loads, check query params and show appropriate
   component
  4. Industry standard - This is how major SPAs handle external redirects

  IMPLEMENTATION:

  1. Change SingleEventPage.tsx:
  const successUrl = getAppUrl(`/?payment=success&event=${slug}`)
  const cancelUrl = getAppUrl(`/?payment=cancel&event=${slug}`)

  2. In your App.tsx or Router, check for payment params:
  useEffect(() => {
    const params = new URLSearchParams(window.location.search)
    if (params.get('payment') === 'success') {
      const eventSlug = params.get('event')
      const sessionId = params.get('session_id')
      // Show success component or navigate to success page
      navigate(`/events/${eventSlug}/payment-success?session_id=${sessionId}`)
    }
  }, [])

  ALTERNATIVE: Use Hash Routing for Payment Only

  const successUrl = getAppUrl(`/#/payment-success/${slug}`)

  WHY BIG COMPANIES DO THIS:

  - Shopify - Redirects to root with params
  - WooCommerce - Uses root URL with order params
  - Many SaaS - Redirect to dashboard with success params

  This avoids ALL Vercel routing issues because the root URL ALWAYS works!

  STOPPED.